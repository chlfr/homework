/* Создайте приложение, которое будет выполнять следующие операции:
            Получить список пользователей с сервера (реальный запрос делать не надо, имитировать ответ с задержкой через setTimeOut).
            Для каждого пользователя получить список задач.
            Объединить данные пользователей и задач в один массив объектов.
            Отобразить результат в консоли.
Шаги
            Создайте функции для выполнения асинхронных запросов:
            Функция fetchUsers должна возвращать промис, который разрешается списком пользователей.
            Функция fetchTasksForUser должна принимать userId и возвращать промис, который разрешается списком задач для этого пользователя.
            Создайте основную функцию loadUserData:
            Функция должна использовать Promise.all для параллельного выполнения запросов.
            Объедините данные пользователей и задач в один массив объектов.
Дополнительные задачи
            Добавьте обработку ошибок:
            Обработайте ошибки при выполнении запросов и выведите сообщение об ошибке в консоль.
            Добавьте возможность фильтрации пользователей по количеству задач:
            Фильтруйте пользователей, у которых количество задач больше заданного порога.
 */

const users = [
  // список юзеров
  { id: 1, name: "Anna" },
  { id: 2, name: "Jimin" },
  { id: 3, name: "Charlie" },
];

const tasks = {
  // список задач
  1: [{ id: 1, title: "Task 1 for Anna" }],
  2: [
    { id: 2, title: "Task 3 for Jimin" },
    { id: 2, title: "Task 3 for Anna" },
  ],
  3: [
    { id: 3, title: "Task 1 for Charlie" },
    { id: 3, title: "Task 2 for Charlie" },
  ],
};

function fetchUsers() {
  // функция, имитирующая запрос для получения списка пользователей + обработка ошибок
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() < 0.2) {
        // обработка ошибок
        reject("Ошибка при получении пользователей.");
      } else {
        resolve(users);
      }
    }, 1000); // задержкa 1сек
  });
}

function fetchTasksForUser(userId) {
  // функция, имитирующая запрос для получения задач для отдельного пользователя + обработка ошибок
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() < 0.2) {
        // обработка ошибок
        reject(`Ошибка при получении задач.`);
      } else {
        resolve(tasks[userId] || []);
      }
    }, 1000); // задержкa 1сек
  });
}

async function loadUserData(taskCount) {
  // основная функция, будет использовать Promise.all, чтобы параллельно загружать пользователей и их задачи, а затем объединять данные в один массив объектов
  try {
    const users = await fetchUsers(); // список пользователей

    const tasksPromises = users.map((user) => fetchTasksForUser(user.id)); // создаем массив промисов для получения задач для отдельного пользователя

    const tasksArray = await Promise.all(tasksPromises); // ожидаем, когда все промисы будут разрешены

    const userData = users.map((user, index) => ({
      // объединяем в один массив объектов
      ...user,
      tasks: tasksArray[index],
    }));

    const filteredUsers = userData.filter(
      (user) => user.tasks.length >= taskCount
    ); // фильтруем пользователей по количеству задач

    console.log("Результат:", filteredUsers);
  } catch (error) {
    console.error("Произошла ошибка:", error);
  }
}

loadUserData(2); // вызов функции и фильтрация пользователей с 2 и более задачами
